<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <link rel="icon" type="image/png" href="icon.png">
    <title>High Flight Teleprompter - With Iambic Pentameter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1e1e1e;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        
        #gameCanvas {
            display: block;
            cursor: default;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            touch-action: none;
        }
        
        .hidden {
            display: none;
        }

        #recordingInstructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border: 3px solid #ff6600;
            border-radius: 15px;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            text-align: center;
            z-index: 1000;
            display: none;
            max-width: 600px;
        }

        #recordingInstructions h2 {
            color: #ff6600;
            margin-top: 0;
            font-size: 32px;
        }

        #recordingInstructions .step {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 102, 0, 0.1);
            border-left: 4px solid #ff6600;
        }
    </style>
</head>
<body>
    <div id="recordingInstructions">
        <h2>üéôÔ∏è AUDIO COORDINATION SETUP</h2>
        <div class="step">1. Start Total Recorder for recording</div>
        <div class="step">2. Set it to record from Roland UA-4FX</div>
        <div class="step">3. Use Audition for audio playback</div>
        <div class="step">4. Recording and playback are mutually exclusive</div>
        <div class="step">5. Listen for different beep patterns</div>
        <br>
        <button onclick="closeRecordingInstructions()" style="
            background: #ff6600; 
            color: white; 
            border: none; 
            padding: 15px 30px; 
            font-size: 20px; 
            font-family: 'Courier New', monospace;
            border-radius: 5px;
            cursor: pointer;">OK - AUDIO APPS READY</button>
    </div>

    <canvas id="gameCanvas" width="1920" height="1020"></canvas>

    <!-- Include the controls module -->
    <!-- 
    This file uses a modular approach for controls functionality:
    - controlsModule.js: Contains all controls-related logic (image loading, button detection, drawing)
    - This HTML file: Contains the main application logic and uses the controls module via a clean API
    
    Benefits of this modular approach:
    - Reusable controls logic across multiple applications
    - Cleaner separation of concerns
    - Easier maintenance and testing
    - Reduced code duplication
    
    Usage: The controls module is imported and instantiated as 'controls' object,
    then used throughout the application for all controls-related functionality.
    -->
    <script src="controlsModule.js"></script>

    <script>
        // High Flight poem - clean text only, blank line removed
        const HIGH_FLIGHT_LINES = [
            "Oh! I have slipped the surly bonds of Earth",
            "And danced the skies on laughter-silvered wings;",
            "Sunward I've climbed, and joined the tumbling mirth",
            "of sun-split clouds, ‚Äî and done a hundred things",
            "You have not dreamed of ‚Äì wheeled and soared and swung",
            "High in the sunlit silence. Hov'ring there,",
            "I've chased the shouting wind along, and flung",
            "My eager craft through footless halls of air....",
            "Up, up the long, delirious, burning blue",
            "I've topped the wind-swept heights with easy grace.",
            "Where never lark, or even eagle flew ‚Äî",
            "And, while with silent, lifting mind I've trod",
            "The high untrespassed sanctity of space,",
            "Put out my hand, and touched the face of God."
        ];

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Screen dimensions
        const SCREEN_WIDTH = 1920;
        const SCREEN_HEIGHT = 1020;
        
        // Initialize controls module
        // This replaces all the inline controls logic from the original hiflite10.html
        // with a clean, reusable module interface
        const controls = new ControlsModule(canvas, ctx, { width: SCREEN_WIDTH, height: SCREEN_HEIGHT });
        
        // Application state
        let applicationRunning = true;
        let animationFrameId = null;
        let initialScrollOffset = 0;
        
        function setupCanvas() {
            canvas.width = SCREEN_WIDTH;
            canvas.height = SCREEN_HEIGHT;
            
            canvas.style.width = '100vw';
            canvas.style.height = '100vh';
            canvas.style.position = 'fixed';
            canvas.style.left = '0';
            canvas.style.top = '0';
            canvas.style.objectFit = 'fill';
            
            return 1.0;
        }
        
        let canvasScale = setupCanvas();
        
        // Position constants
        const POSITION_TITLE = 120;
        
        // Scrolling variables - tuned for 2-minute poem at 1.0x speed
        let scrollOffset = 0.0;
        const baseScrollSpeed = 7.5; // pixels per second for 2-minute poem
        let lastTime = Date.now();
        
        let currentLine = 0;
        let waitingForStart = true;
        let songPaused = false;
        let currentPoemLine = 1; // Global variable for current line display
        
        // Speed control variables - middle position is 2-minute default
        const speedValues = [0.5, 0.75, 1.0, 1.25, 1.5];
        const speedLabels = ["0.5x", "0.75x", "1.0x", "1.25x", "1.5x"];
        let speedCurrentIndex = 2; // Start at middle position (1.0x = 2 minutes)
        let speedDragging = false;
        
        // Iambic pentameter meter variables
        let meterBarEnabled = true;
        let meterStartTime = 0;
        const baseBeatsPerLine = 5;
        let breathingPauseAdded = false;
        let previousLineNumber = -1;
        const baseLineTime = 8.571; // seconds per line at 1.0x speed (2 minutes / 14 lines)
        
        // Button state variables
        let playPauseHovered = false;
        let restartHovered = false;
        
        // Total Recorder coordination variables
        let totalRecorderMode = false;
        let recordingActive = false;
        
        // Playback mode variables
        let playbackMode = "normal";
        let audioFile = null;
        let audioPosition = 0.0;
        
        // Image assets (excluding controls - now handled by module)
        let backgroundImage = null;
        let magTapeImage = null;
        
        // UI button rectangles
        const buttonX = SCREEN_WIDTH - 180;
        const playPauseRect = { x: buttonX, y: 80, width: 160, height: 40 };
        const restartRect = { x: buttonX, y: 130, width: 160, height: 40 };
        const speedRect = { x: buttonX, y: 300, width: 160, height: 20 };
        const meterToggleRect = { x: buttonX, y: 180, width: 160, height: 40 };
        
        // Meter bar drawing function
        function drawMeterBar() {
            if (!meterBarEnabled || waitingForStart || songPaused) {
                return;
            }
            
            const currentTime = Date.now();
            const currentSpeed = speedValues[speedCurrentIndex];
            const lineTime = baseLineTime / currentSpeed; // Adjust line time for speed
            
            // Calculate which line we're on and position within that line
            const timeSinceStart = (currentTime - meterStartTime) / 1000;
            const lineNumber = Math.floor(timeSinceStart / lineTime);
            
            if (lineNumber !== previousLineNumber) {
                breathingPauseAdded = false;
                previousLineNumber = lineNumber;
            }
            
            const currentBeatsPerLine = breathingPauseAdded ? 6 : baseBeatsPerLine;
            const beatTime = lineTime / currentBeatsPerLine;
            
            const timeInLine = timeSinceStart % lineTime;
            const currentBeat = Math.floor(timeInLine / beatTime);
            const progressInBeat = (timeInLine % beatTime) / beatTime;
            
            // Make currentBeat globally accessible for B key
            window.currentBeat = currentBeat;
            
            // Meter bar position and size
            const barX = SCREEN_WIDTH - 30;
            const barWidth = 20;
            const barMaxHeight = 200;
            const barBaseY = SCREEN_HEIGHT / 2 + 100;
            
            // Calculate bar height based on current beat
            let barHeight = 0;
            
            if (currentBeat < 5) {
                // During stressed beats (1-5): bar grows then shrinks
                const beatProgress = progressInBeat < 0.5 ? progressInBeat * 2 : (1 - progressInBeat) * 2;
                barHeight = beatProgress * barMaxHeight;
            } else {
                // During breathing pause (beat 6): bar stays low
                barHeight = Math.sin(progressInBeat * Math.PI) * (barMaxHeight * 0.2);
            }
            
            // Draw the meter bar
            const barY = barBaseY - barHeight;
            
            // Bar color - different for stressed beats vs breathing pause
            let barColor;
            if (currentBeat < 5) {
			// Stressed beats - light to dark brown
				const intensity = barHeight / barMaxHeight;
				barColor = `rgb(${Math.floor(139 + 60 * intensity)}, ${Math.floor(69 + 30 * intensity)}, ${Math.floor(19 + 10 * intensity)})`;
			} else {
			// Breathing pause - muted tan
				const intensity = barHeight / (barMaxHeight * 0.2);
				barColor = `rgb(${Math.floor(160 + 50 * intensity)}, ${Math.floor(140 + 40 * intensity)}, ${Math.floor(100 + 30 * intensity)})`;
			}
            
            // Draw bar background
            ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
            ctx.fillRect(barX, barBaseY - barMaxHeight, barWidth, barMaxHeight);
            
            // Draw active bar
            ctx.fillStyle = barColor;
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            // Draw bar outline
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barBaseY - barMaxHeight, barWidth, barMaxHeight);
            
            // Label
            ctx.fillStyle = 'white';
            ctx.font = '14px "Courier New"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('METER', barX + barWidth/2, barBaseY - barMaxHeight - 20);
            
            // Beat indicator
            const beatText = currentBeat < 5 ? `${currentBeat + 1}/5` : 'BREATHE';
            ctx.fillText(beatText, barX + barWidth/2, barBaseY + 10);
        }
        
        // Audio cue functions
        function playBeep(frequency, duration, volume) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration / 1000);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }
        
        function playStartRecordingBeep() {
            playBeep(600, 150, 0.15);
            setTimeout(function() { playBeep(800, 150, 0.15); }, 200);
            setTimeout(function() { playBeep(1000, 300, 0.15); }, 400);
        }
        
        function playStopRecordingBeep() {
            playBeep(800, 200, 0.15);
            setTimeout(function() { playBeep(400, 400, 0.15); }, 300);
        }
        
        function playStartPlaybackBeep() {
            playBeep(1200, 100, 0.15);
            setTimeout(function() { playBeep(1200, 100, 0.15); }, 150);
        }
        
        function playStopPlaybackBeep() {
            playBeep(300, 500, 0.15);
        }
        
        // Application control functions
        function quitApplication() {
            console.log('Quitting High Flight Teleprompter...');
            applicationRunning = false;
            
            if (totalRecorderMode) {
                stopTotalRecorderCoordination();
            }
            
            if (playbackMode === "playback_active") {
                stopAuditionPlayback();
            }
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // Navigate back to the folder containing this HTML file
            const currentUrl = window.location.href;
            const folderUrl = currentUrl.substring(0, currentUrl.lastIndexOf('/'));
            window.location.href = folderUrl;
        }
        
        // Total Recorder coordination functions
        function startTotalRecorderCoordination() {
            if (totalRecorderMode) {
                return;
            }
            
            console.log('üéôÔ∏è Starting Total Recorder coordination...');
            totalRecorderMode = true;
            recordingActive = true;
            
            playStartRecordingBeep();
            
            setTimeout(function() {
                console.log('‚ñ∂Ô∏è START RECORDING IN TOTAL RECORDER NOW!');
            }, 100);
        }
        
        function stopTotalRecorderCoordination() {
            if (!totalRecorderMode) {
                return;
            }
            
            console.log('üõë Stopping Total Recorder coordination...');
            totalRecorderMode = false;
            recordingActive = false;
            
            playStopRecordingBeep();
            
            setTimeout(function() {
                console.log('‚èπÔ∏è STOP RECORDING IN TOTAL RECORDER NOW!');
            }, 100);
        }
        
        function toggleTotalRecorderCoordination() {
            if (totalRecorderMode) {
                stopTotalRecorderCoordination();
            } else {
                if (playbackMode !== "normal") {
                    console.log("üö´ Cannot record while in playback mode - stop playback first");
                    playBeep(200, 200, 0.2);
                    return;
                }
                startTotalRecorderCoordination();
            }
        }
        
        function startAuditionPlayback() {
            if (totalRecorderMode) {
                console.log("üö´ Cannot start playback while recording - stop recording first");
                playBeep(200, 200, 0.2);
                return;
            }
            
            console.log('üéµ Starting Audition playback coordination...');
            playStartPlaybackBeep();
            
            setTimeout(function() {
                console.log('‚ñ∂Ô∏è START PLAYBACK IN AUDITION NOW!');
            }, 100);
        }
        
        function stopAuditionPlayback() {
            console.log('üõë Stopping Audition playback coordination...');
            playStopPlaybackBeep();
            
            setTimeout(function() {
                console.log('‚èπÔ∏è STOP PLAYBACK IN AUDITION NOW!');
            }, 100);
        }
        
        function showRecordingInstructions() {
            document.getElementById('recordingInstructions').style.display = 'block';
        }
        
        function closeRecordingInstructions() {
            document.getElementById('recordingInstructions').style.display = 'none';
        }
        
        // Fast forward/rewind functions
        function jumpToNextLine() {
            const lineHeight = 60;
            const maxLines = HIGH_FLIGHT_LINES.filter(l => l.trim()).length;
            const currentScrollLine = Math.floor((scrollOffset - initialScrollOffset) / lineHeight);
            
            if (currentScrollLine < maxLines - 1) {
                scrollOffset += lineHeight;
                console.log('Jumped forward one line');
            }
        }
        
        function jumpToPreviousLine() {
            const lineHeight = 60;
            const currentScrollLine = Math.floor((scrollOffset - initialScrollOffset) / lineHeight);
            
            if (currentScrollLine > 0) {
                scrollOffset -= lineHeight;
                console.log('Jumped back one line');
            }
        }
        
        function showPlaybackPrompt(action) {
            const message = `Use ${action} controls in Total Recorder or Audition`;
            console.log(`üéµ ${message}`);
            playBeep(800, 200, 0.15);
        }
        
        // Utility functions
        function rgbToString(rgb) {
            return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        }
        
        // Button drawing functions
        function drawButton(rect, text, isHovered, isPressed, color, textColor) {
            let buttonColor = color || [0, 102, 204];
            if (isPressed) {
                buttonColor = [0, 80, 160];
            } else if (isHovered) {
                buttonColor = [0, 128, 255];
            }
            
            ctx.fillStyle = rgbToString(buttonColor);
            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
            
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
            
            ctx.fillStyle = rgbToString(textColor || [255, 255, 255]);
            ctx.font = 'bold 24px "Courier New"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, rect.x + rect.width/2, rect.y + rect.height/2);
        }
        
        function isPointInRect(point, rect) {
            return point.x >= rect.x && point.x <= rect.x + rect.width &&
                   point.y >= rect.y && point.y <= rect.y + rect.height;
        }
        
        // Speed slider functions
        function drawSpeedSlider(rect, currentIndex, labelText) {
            const knobRadius = 10;
            
            ctx.fillStyle = 'rgb(100, 100, 100)';
            ctx.fillRect(rect.x, rect.y + rect.height/2 - 2, rect.width, 4);
            
            for (let i = 0; i < speedValues.length; i++) {
                const markerX = rect.x + (i / (speedValues.length - 1)) * rect.width;
                ctx.fillStyle = 'rgb(150, 150, 150)';
                ctx.beginPath();
                ctx.arc(markerX, rect.y + rect.height/2, 3, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            const knobX = rect.x + (currentIndex / (speedValues.length - 1)) * rect.width;
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(knobX, rect.y + rect.height/2, knobRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = 'rgb(0, 102, 204)';
            ctx.beginPath();
            ctx.arc(knobX, rect.y + rect.height/2, knobRadius - 2, 0, 2 * Math.PI);
            ctx.fill();
            
            const currentLabel = speedLabels[currentIndex];
            ctx.fillStyle = 'white';
            ctx.font = '18px "Courier New"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const label = labelText || "Speed";
            ctx.fillText(`${label}: ${currentLabel}`, rect.x + rect.width/2, rect.y - 15);
        }
        
        function handleSpeedSliderClick(rect, pos) {
            if (!isPointInRect(pos, rect)) {
                return false;
            }
            
            const relativeX = pos.x - rect.x;
            const progress = Math.max(0, Math.min(1, relativeX / rect.width));
            const newIndex = Math.round(progress * (speedValues.length - 1));
            
            if (newIndex !== speedCurrentIndex) {
                speedCurrentIndex = newIndex;
                return true;
            }
            return false;
        }
        
        // Load non-control images
        function initializeImages() {
            backgroundImage = new Image();
            backgroundImage.onload = function() {
                console.log('Background loaded');
            };
            backgroundImage.onerror = function() {
                console.log('Background.jpg failed, trying .jpeg');
                const bgImg2 = new Image();
                bgImg2.onload = function() {
                    backgroundImage = bgImg2;
                    console.log('Background loaded as .jpeg');
                };
                bgImg2.onerror = function() {
                    console.log('Both background formats failed, using default');
                    createDefaultBackground();
                };
                bgImg2.src = 'background.jpeg';
            };
            backgroundImage.src = 'background.jpg';
            
            magTapeImage = new Image();
            magTapeImage.onload = function() {
                console.log('Mag tape loaded');
            };
            magTapeImage.onerror = function() {
                console.log('Mag tape failed to load, using default');
                createDefaultTape();
            };
            magTapeImage.src = 'magtape.jpg';
        }
        
        function createDefaultBackground() {
            const bgCanvas = document.createElement('canvas');
            bgCanvas.width = SCREEN_WIDTH;
            bgCanvas.height = SCREEN_HEIGHT;
            const bgCtx = bgCanvas.getContext('2d');
            
            const gradient = bgCtx.createLinearGradient(0, 0, 0, SCREEN_HEIGHT);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f3460');
            bgCtx.fillStyle = gradient;
            bgCtx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            
            backgroundImage = new Image();
            backgroundImage.src = bgCanvas.toDataURL();
        }
        
        function createDefaultTape() {
            const tapeCanvas = document.createElement('canvas');
            const tapeHeight = Math.floor(SCREEN_HEIGHT / 8);
            tapeCanvas.width = SCREEN_WIDTH;
            tapeCanvas.height = tapeHeight;
            const tapeCtx = tapeCanvas.getContext('2d');
            
            const tapeGradient = tapeCtx.createLinearGradient(0, 0, 0, tapeHeight);
            tapeGradient.addColorStop(0, '#c0c0c0');
            tapeGradient.addColorStop(0.5, '#808080');
            tapeGradient.addColorStop(1, '#404040');
            tapeCtx.fillStyle = tapeGradient;
            tapeCtx.fillRect(0, 0, SCREEN_WIDTH, tapeHeight);
            
            magTapeImage = new Image();
            magTapeImage.src = tapeCanvas.toDataURL();
        }
        
        // Define controls button callbacks
        // These callbacks define what happens when each control button is pressed
        // The controls module will call the appropriate callback when a button is clicked
        const controlsCallbacks = {
            playback_mode: function() {
                if (totalRecorderMode) {
                    console.log("üö´ Cannot change to playback mode while recording");
                    playBeep(200, 200, 0.2);
                    return;
                }
                
                if (playbackMode === "normal") {
                    playbackMode = "playback_idle";
                    console.log("Switched to playback mode (idle) - Ready for Audition");
                } else if (playbackMode === "playback_idle") {
                    playbackMode = "playback_active";
                    startAuditionPlayback();
                    console.log("Started audio playback coordination");
                } else {
                    playbackMode = "normal";
                    stopAuditionPlayback();
                    console.log("Stopped playback, returned to normal mode");
                }
            },
            
            forward: function() {
                if (playbackMode === "normal") {
                    if (waitingForStart) {
                        waitingForStart = false;
                        meterStartTime = Date.now(); // Start meter timing
                    } else if (songPaused) {
                        songPaused = false;
                    } else {
                        songPaused = true;
                    }
                } else {
                    if (totalRecorderMode) {
                        console.log("üö´ Cannot control playback while recording");
                        playBeep(200, 200, 0.2);
                        return;
                    }
                    
                    if (playbackMode === "playback_idle") {
                        playbackMode = "playback_active";
                        startAuditionPlayback();
                        console.log("Started audio playback coordination");
                    } else if (playbackMode === "playback_active") {
                        playbackMode = "playback_idle";
                        stopAuditionPlayback();
                        console.log("Paused audio playback coordination");
                    }
                }
            },
            
            fast_forward: function() {
                if (playbackMode === "normal") {
                    jumpToNextLine();
                } else {
                    showPlaybackPrompt("fast forward");
                }
            },
            
            fast_rewind: function() {
                if (playbackMode === "normal") {
                    jumpToPreviousLine();
                } else {
                    showPlaybackPrompt("rewind");
                }
            },
            
            pause: function() {
                if (playbackMode === "normal") {
                    if (!waitingForStart) {
                        songPaused = !songPaused;
                    }
                } else {
                    if (totalRecorderMode) {
                        console.log("üö´ Cannot control playback while recording");
                        playBeep(200, 200, 0.2);
                        return;
                    }
                    
                    if (playbackMode === "playback_active") {
                        playbackMode = "playback_idle";
                        stopAuditionPlayback();
                        console.log("Paused audio playback coordination");
                    }
                }
            },
            
            stop_eject: function() {
                if (playbackMode !== "normal") {
                    if (totalRecorderMode) {
                        console.log("üö´ Cannot stop playback while recording");
                        playBeep(200, 200, 0.2);
                        return;
                    }
                    
                    if (playbackMode === "playback_active") {
                        stopAuditionPlayback();
                    }
                    playbackMode = "playback_idle";
                    console.log("Stopped audio playback coordination");
                }
                currentLine = 0;
                waitingForStart = true;
                songPaused = false;
                scrollOffset = 0.0; // Will be reset to initial position in draw()
                meterStartTime = 0; // Reset meter timing
            },
            
            record: function() {
                if (playbackMode === "normal") {
                    if (!totalRecorderMode) {
                        showRecordingInstructions();
                    } else {
                        toggleTotalRecorderCoordination();
                    }
                } else {
                    console.log("Recording disabled during playback mode");
                }
            }
        };
        
        // Main drawing function
        function draw() {
            ctx.fillStyle = 'rgb(30, 30, 30)';
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            
            if (backgroundImage && backgroundImage.complete) {
                ctx.drawImage(backgroundImage, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            }
            
            if (magTapeImage && magTapeImage.complete) {
                const tapeHeight = Math.floor(SCREEN_HEIGHT / 8);
                ctx.drawImage(magTapeImage, 0, 0, SCREEN_WIDTH, tapeHeight);
                
                const indicatorWidth = 8;
                // Calculate dynamic position based on current progress through poem
                const totalLines = HIGH_FLIGHT_LINES.filter(l => l.trim()).length;
                const progress = currentPoemLine / totalLines;
                const positionX = 50 + (progress * (SCREEN_WIDTH - 100));
                const indicatorHeight = tapeHeight / 2;
                const indicatorY = tapeHeight / 4;
                
                const rectX = positionX - indicatorWidth / 2;
                ctx.fillStyle = 'rgb(0, 255, 0)';
                ctx.fillRect(rectX, indicatorY, indicatorWidth, indicatorHeight);
                
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(rectX + indicatorWidth/2, indicatorY + indicatorHeight/2, 5, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Draw controls using the module
            // Pass current application state to the controls module for proper display
            const controlsState = {
                currentPoemLine: currentPoemLine,
                playbackMode: playbackMode,
                totalRecorderMode: totalRecorderMode
            };
            controls.draw(controlsState);
            
            // Draw title with nice green color
            ctx.fillStyle = 'rgb(50, 255, 150)';
            ctx.font = 'bold 40px "Courier New"';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText("High Flight - by John Gillespie Magee Jr.", 50, POSITION_TITLE);
            
            // Measure all poem lines for window sizing
            ctx.font = '48px Arial';
            let maxWidth = 0;
            let maxHeight = 0;
            
            for (let i = 0; i < HIGH_FLIGHT_LINES.length; i++) {
                const line = HIGH_FLIGHT_LINES[i];
                if (line.trim()) {
                    const metrics = ctx.measureText(line);
                    maxWidth = Math.max(maxWidth, metrics.width);
                    maxHeight = Math.max(maxHeight, 48);
                }
            }
            
            // Define lineHeight before using it
            const lineHeight = 60;
            
            // Calculate initial scroll offset to center first line in reading box
            const windowWidth = Math.floor(maxWidth * 1.15);
            const windowHeight = Math.floor(maxHeight * 1.15);
            const windowX = (SCREEN_WIDTH - windowWidth) / 2;
            const windowY = (SCREEN_HEIGHT - windowHeight) / 2;
            
            // Calculate where first line should start (center of reading box)
            const readingBoxCenter = windowY + windowHeight / 2;
            const baseStartY = windowY + windowHeight + (lineHeight / 2);
            initialScrollOffset = baseStartY - readingBoxCenter;
            
            // If this is the first frame, set scrollOffset to initial position
            if (scrollOffset === 0 && waitingForStart) {
                scrollOffset = initialScrollOffset;
            }
            
            // Draw blue window frame
            ctx.strokeStyle = 'rgb(100, 100, 255)';
            ctx.lineWidth = 4;
            ctx.strokeRect(windowX, windowY, windowWidth, windowHeight);
            
            // Display poem text with smooth scrolling
            const startY = baseStartY - scrollOffset;
            
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            for (let i = 0; i < HIGH_FLIGHT_LINES.length; i++) {
                const line = HIGH_FLIGHT_LINES[i];
                if (line.trim()) {
                    const lineY = startY + i * lineHeight;
                    if (lineY > -lineHeight && lineY < SCREEN_HEIGHT) {
                        ctx.fillText(line, SCREEN_WIDTH / 2, lineY);
                    }
                }
            }
            
            // Draw the iambic pentameter meter bar
            drawMeterBar();
            
            // Show Total Recorder coordination status
            if (totalRecorderMode) {
                ctx.fillStyle = 'rgb(255, 50, 50)';
                ctx.font = 'bold 36px "Courier New"';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText("‚óè TOTAL RECORDER ACTIVE", SCREEN_WIDTH - 450, 40);
                
                const flashTime = Date.now() % 1000;
                if (flashTime < 500) {
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.3)';
                    ctx.fillRect(SCREEN_WIDTH - 480, 30, 460, 50);
                }
            } else {
                ctx.fillStyle = 'rgb(100, 255, 100)';
                ctx.font = 'bold 24px "Courier New"';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText("Total Recorder Ready", SCREEN_WIDTH - 250, 50);
            }
            
            // Show playback mode status
            if (playbackMode !== "normal") {
                const modeText = playbackMode === "playback_idle" ? "PLAYBACK IDLE" : "PLAYBACK ACTIVE";
                const modeColor = playbackMode === "playback_idle" ? 'rgb(255, 255, 0)' : 'rgb(255, 100, 100)';
                ctx.fillStyle = modeColor;
                ctx.font = 'bold 20px "Courier New"';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(modeText, SCREEN_WIDTH - 200, 100);
            }
            
            // Draw UI buttons
            const playText = (!waitingForStart && !songPaused) ? "Pause" : "Play";
            drawButton(playPauseRect, playText, playPauseHovered, false);
            drawButton(restartRect, "Restart", restartHovered, false);
            drawButton(meterToggleRect, meterBarEnabled ? "Meter: ON" : "Meter: OFF", false, false, 
                      meterBarEnabled ? [0, 150, 0] : [150, 150, 150]);
            
            // Draw speed slider
            drawSpeedSlider(speedRect, speedCurrentIndex);
            
            // Draw abbreviated help text at bottom right - wrapped for readability
            const helpStartY = SCREEN_HEIGHT - 270;
            const helpStartX = SCREEN_WIDTH - 280;
            const helpLines = [
                "Space=Play R=Restart", 
                "Q=Quit M=Meter B=Breath",
                "REC: 3‚ÜëStart 2‚ÜìStop", 
                "PLAY: 2Hi=Start 1Lo=Stop",
                "FF/FR: Line jump (or prompt)"
            ];
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(helpStartX - 10, helpStartY - 10, 270, 140);
            
            ctx.fillStyle = 'white';
            ctx.font = '16px "Courier New"';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            
            for (let i = 0; i < helpLines.length; i++) {
                ctx.fillText(helpLines[i], helpStartX, helpStartY + i * 20);
            }

            // Show large coordination message during recording or playback
            if (totalRecorderMode || playbackMode === "playback_active") {
                const messageY = SCREEN_HEIGHT - 100;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, messageY - 30, SCREEN_WIDTH, 60);
                
                let messageText = "";
                let messageColor = "";
                
                if (totalRecorderMode) {
                    messageText = "üéôÔ∏è COORDINATING WITH TOTAL RECORDER - LISTEN FOR BEEP SIGNALS";
                    messageColor = 'rgb(255, 255, 50)';
                } else if (playbackMode === "playback_active") {
                    messageText = "üéµ COORDINATING WITH AUDITION PLAYBACK - LISTEN FOR BEEP SIGNALS";
                    messageColor = 'rgb(50, 255, 255)';
                }
                
                ctx.fillStyle = messageColor;
                ctx.font = 'bold 32px "Courier New"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(messageText, SCREEN_WIDTH / 2, messageY);
            }
        }
        
        // Update function
        function update() {
            const currentTime = Date.now();
            
            if (playbackMode === "normal") {
                if (!waitingForStart && !songPaused) {
                    const dt = (currentTime - lastTime) / 1000;
                    const currentSpeed = baseScrollSpeed * speedValues[speedCurrentIndex];
                    scrollOffset += currentSpeed * dt;
                }
            } else {
                if (playbackMode === "playback_active") {
                    if (!waitingForStart && !songPaused) {
                        const dt = (currentTime - lastTime) / 1000;
                        const currentSpeed = baseScrollSpeed * speedValues[speedCurrentIndex];
                        scrollOffset += currentSpeed * dt;
                    }
                }
            }
            
            // Calculate current poem line for display
            const lineHeight = 60;
            const windowHeight = 55;
            const windowY = (SCREEN_HEIGHT - windowHeight) / 2;
            const readingBoxCenter = windowY + windowHeight / 2;
            const baseStartY = windowY + windowHeight + (lineHeight / 2);
            const startY = baseStartY - scrollOffset;
            const readingBoxCenterY = windowY + windowHeight / 2;
            
            let newCurrentPoemLine = 1;
            let minDistance = Infinity;
            
            for (let i = 0; i < HIGH_FLIGHT_LINES.length; i++) {
                const line = HIGH_FLIGHT_LINES[i];
                if (line.trim()) {
                    const lineY = startY + i * lineHeight;
                    const lineCenterY = lineY + lineHeight / 2;
                    const distance = Math.abs(lineCenterY - readingBoxCenterY);
                    if (distance < minDistance) {
                        minDistance = distance;
                        newCurrentPoemLine = i + 1;
                    }
                }
            }
            
            currentPoemLine = newCurrentPoemLine;
            lastTime = currentTime;
        }
        
        // Event handlers
        function getTouchPos(event) {
            const rect = canvas.getBoundingClientRect();
            const touch = event.touches[0] || event.changedTouches[0];
            return {
                x: (touch.clientX - rect.left) * (SCREEN_WIDTH / rect.width),
                y: (touch.clientY - rect.top) * (SCREEN_HEIGHT / rect.height)
            };
        }
        
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (event.clientX - rect.left) * (SCREEN_WIDTH / rect.width),
                y: (event.clientY - rect.top) * (SCREEN_HEIGHT / rect.height)
            };
        }
        
        function handleKeyDown(event) {
            if (!applicationRunning) {
                return;
            }
            
            switch (event.code) {
                case 'Escape':
                case 'KeyQ':
                    quitApplication();
                    break;
                    
                case 'Space':
                    event.preventDefault();
                    if (waitingForStart) {
                        waitingForStart = false;
                        meterStartTime = Date.now(); // Start meter timing
                    } else if (songPaused) {
                        songPaused = false;
                    } else {
                        songPaused = true;
                    }
                    break;
                    
                case 'KeyR':
                    currentLine = 0;
                    waitingForStart = true;
                    songPaused = false;
                    scrollOffset = 0.0; // Will be reset to initial position in draw()
                    meterStartTime = 0; // Reset meter timing
                    break;
                    
                case 'KeyM':
                    meterBarEnabled = !meterBarEnabled;
                    console.log('Meter bar:', meterBarEnabled ? 'ON' : 'OFF');
                    break;
					
                case 'KeyB':
                    if (meterBarEnabled && !waitingForStart && window.currentBeat === 4 && !breathingPauseAdded) {
                        breathingPauseAdded = true;
                        console.log('Breathing pause added to current line');
                    }
                    break;
            }
        }
        
        function handleMouseMove(event) {
            const mousePos = getMousePos(event);
            updateHoverStates(mousePos);
        }
        
        function handleTouchMove(event) {
            event.preventDefault();
            const touchPos = getTouchPos(event);
            updateHoverStates(touchPos);
        }
        
        function updateHoverStates(pos) {
            playPauseHovered = isPointInRect(pos, playPauseRect);
            restartHovered = isPointInRect(pos, restartRect);
        }
        
        function handleMouseDown(event) {
            const mousePos = getMousePos(event);
            handlePointerDown(mousePos);
        }
        
        function handleTouchStart(event) {
            event.preventDefault();
            const touchPos = getTouchPos(event);
            handlePointerDown(touchPos);
        }
        
        function handlePointerDown(pos) {
            if (!applicationRunning) {
                return;
            }
            
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            
            if (isPointInRect(pos, playPauseRect)) {
                if (waitingForStart) {
                    waitingForStart = false;
                    meterStartTime = Date.now(); // Start meter timing
                } else if (songPaused) {
                    songPaused = false;
                } else {
                    songPaused = true;
                }
                return;
            }
            
            if (isPointInRect(pos, restartRect)) {
                currentLine = 0;
                waitingForStart = true;
                songPaused = false;
                scrollOffset = 0.0; // Will be reset to initial position in draw()
                meterStartTime = 0; // Reset meter timing
                return;
            }
            
            if (isPointInRect(pos, meterToggleRect)) {
                meterBarEnabled = !meterBarEnabled;
                console.log('Meter bar:', meterBarEnabled ? 'ON' : 'OFF');
                return;
            }
            
            if (handleSpeedSliderClick(speedRect, pos)) {
                return;
            }
            
            // Handle controls clicks using the module
            // This replaces the large switch statement that was in the original file
            if (controls.handleClick(pos, controlsCallbacks)) {
                return; // Controls module handled the click
            }
        }
        
        // Animation loop
        function gameLoop() {
            if (!applicationRunning) {
                return;
            }
            
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // Initialize and start
        function init() {
            // Initialize controls module
            controls.initialize();
            
            // Initialize other images
            initializeImages();
            
            document.addEventListener('keydown', handleKeyDown);
            
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mousedown', handleMouseDown);
            
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', function(e) { e.preventDefault(); }, { passive: false });
            
            canvas.addEventListener('contextmenu', function(e) { e.preventDefault(); });
            
            document.addEventListener('touchstart', function(e) {
                if (e.target === canvas) e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('touchmove', function(e) {
                if (e.target === canvas) e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('touchend', function(e) {
                if (e.target === canvas) e.preventDefault();
            }, { passive: false });
            
            window.addEventListener('resize', function() {
                canvasScale = setupCanvas();
                controls.updateSize(); // Update controls module on resize
            });
            
            window.addEventListener('orientationchange', function() {
                setTimeout(function() {
                    canvasScale = setupCanvas();
                    controls.updateSize(); // Update controls module on orientation change
                }, 100);
            });
            
            gameLoop();
            
            console.log('High Flight Teleprompter initialized - WITH IAMBIC PENTAMETER BAR');
            console.log('üéôÔ∏è Total Recorder Integration Ready');
            console.log('üéµ Audition Playback Coordination Ready');
            console.log('üìè Iambic Pentameter Meter Bar Ready');
            console.log('üéõÔ∏è Controls Module Loaded');
            console.log('Click Record button to coordinate with Total Recorder');
            console.log('Click Playback Mode button to coordinate with Audition');
            console.log('Press M or click Meter button to toggle meter bar');
            console.log('Press B during beat 5 to add breathing pause');
            console.log('FF/FR buttons: Line jump in normal mode, prompt in playback mode');
            console.log('BEEP PATTERNS:');
            console.log('  Record: 3 ascending = START, 2 descending = STOP');
            console.log('  Playback: 2 quick high = START, 1 long low = STOP');
        }
        
        window.addEventListener('load', init);
        
        window.addEventListener('beforeunload', function() {
            if (totalRecorderMode) {
                stopTotalRecorderCoordination();
            }
        });
    </script>
</body>
</html>